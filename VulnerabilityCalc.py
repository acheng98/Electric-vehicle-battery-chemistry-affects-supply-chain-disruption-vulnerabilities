"""
This code takes the compiled material flows data from SankeyData.py, and calculates the vulnerability index (country dependence)
for any set of countries and cathode-mineral pair.
Plots by this script generate the figures found in Fig. 5, Fig. D3-1, and Fig. D3-2 of the paper. 


ChatGPT assisted in writing some of the code and documentation. 
Implementation of Edmonds-Karp algorithm adapted from https://github.com/anxiaonong/Maxflow-Algorithms/blob/master/Edmonds-Karp%20Algorithm.py

"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick

# GLOBAL VARIABLES
MRMT = "Missing Refined Material Trade"
URMS = "Unknown Raw Material Source"
UARP = "Unaccounted for Additional Refining Production" 
TFCR = "Trade from countries with no refining" 
TFCM = "Trade from countries with no mining"

ACRO = [MRMT,URMS+"_mine",UARP,TFCR,TFCM]

COLORS = {"China": "#E81313", "Australia": "#DB05AA", "Russian Federation": "#B7B7B7", 
				"Indonesia": "#53C55E", "Congo, Democratic Republic of the": "#028573", 
				"South Africa": "#773F05", "Japan": "#FB9431", "Korea, Republic of": "#6D9EEB", 
				"Argentina": "#F6B50C","Chile": "#008A03", "United States of America": "#635EFF", 
				"Canada": "#01FFFF", "Brazil": "#009639", 
				# "Portugal": "#016201", "Zimbabwe": "#056002", "Belgium": "#C8102E", "Finland": "#351c75", 
				"India": "#FF9933", # "Madagascar": "#F2D2BD", "Morocco": "#C1272D",
				# "Norway": "#3d85c6", "Zambia": "#FFC0CB", "Cuba": "#ADD8E6", "Papua New Guinea": "#FFCD00",
				"Philippines": "#FFD580", # "France": "#dd7e6b", "United Kingdom": "#9e9e9e", 
				"New Caledonia": "#dd7e6b", # "Colombia": "#FFCD00", "Greece": "#001489", "Spain": "#AA151B", 
				# "Myanmar": "#FFCD00", "Cote d'Ivoire": "#FF8200", "Gabon": "#009E60", "Georgia": "#DA291C", 
				# "Ghana": "#EF3340", "Kazakhstan": "#00AFCA", "Malaysia": "#0032A0", "Mexico": "#006341", 
				# "Ukraine": "#0057B7", "Vietnam": "#C8102E",
				"Missing": "#CCCCCC", "Other": "#4B535D", 
				"LFP": "#000086", "NCM": "#000086", "NCA": "#000086", "LMO": "#000086", "LCO": "#000086"}

def commonname(country_list):
	'''
	A function to provide a common name for a given list of countries, given that trade data sometimes uses 
	long-form or official country names. 

	Input:
		country_list (list): A list of country names to convert to common names
	Output:
		(str or list): Returns a string or list replacing specific combinations of countries or specific countries'
			names with their common names or shortened equivalent. 
	'''
	if PRINT_debug: print(country_list)
	common = {"Congo, Democratic Republic of the": "DRC", 
				"Russian Federation": "Russia",
				"Korea, Republic of": "South Korea",
				"United States of America": "USA"}
	out = []
	if len(country_list) > 10:
		return "EU* & UK" # Hack/workaround for Europe
	elif len(country_list) == 10:
		return "US and its Free Trade Countries"
	elif country_list == ["China","Russian Federation"]:
		return "China and Russia"
	elif country_list == ["China","Congo, Democratic Republic of the","Philippines","Indonesia"]:
		return "China and Chinese company-owned Nickel & Cobalt bloc"
	elif country_list == ["Chile","Argentina","Bolivia","Brazil","Peru"]:
		return "South American lithium bloc"
	else:
		for c in country_list:
			if c in common:
				out.append(common[c])
			else:
				out.append(c)
	return out

def bfs(C, F, s, t):
	'''
	An implementation of breadth-first search to find a path in a flow network.

	Inputs:
		C (list of lists): The capacity matrix representing the flow network.
		F (list of lists): The flow matrix representing the current flow in the network.
		s (int): The source node.
		t (int): The target node.

	Outputs:
		list or None: Returns a list of edges representing the path from the source (s) to the target (t) in the flow network.
					  If no path exists, returns None.

	'''
	queue = [s]
	paths = {s: []}
	if s == t:
		return paths[s]
	while queue:
		u = queue.pop(0)
		for v in range(len(C)):
			if (C[u][v] - F[u][v] > 0) and v not in paths:
				paths[v] = paths[u] + [(u, v)]
				if v == t:
					return paths[v]
				queue.append(v)
	return None

def dfs(graph, start, switch):
	'''
	An implementation of Depth-First Search (DFS) algorithm for traversing a graph.

	Inputs:
		graph (DataFrame): A DataFrame representing the graph structure with "Source" and "Target" columns.
		start: The starting vertex for DFS traversal.
		switch (bool): A switch to control the traversal direction.
			- If True, performs 'bottom-up' DFS from the source to the target
			- If False, performs 'top-down' DFS from the target to the source

	Outputs:
		list: Returns a list of vertices visited during the DFS traversal.
	'''
	visited = []
	stack = [start]

	while stack:
		vertex = stack.pop()
		if vertex not in visited:
			visited.append(vertex)
			# Switches between 'bottom-up' or 'top-down'
			if switch: # True - 'bottom-up'
				neighbors = list(graph.loc[graph["Target"] == vertex]["Source"])
			else:
				neighbors = list(graph.loc[graph["Source"] == vertex]["Target"])

			for neighbor in neighbors:
				stack.append(neighbor)
	return visited

# Edmonds-Karp Algorithm
def max_flow(C, s, t):
	'''
	Implementation of the Edmonds-Karp algorithm to find the maximum flow in a flow network.

	Inputs:
		C (list of lists): The capacity matrix representing the flow network.
		s (int): The source node.
		t (int): The sink (target) node.

	Outputs:
		tuple: Returns a tuple containing two elements:
			- A 2D list (matrix) F representing the flow through each edge in the network after the algorithm execution.
			- An integer representing the maximum flow from the source (s) to the sink (t).
	'''
	n = len(C) # C is the capacity matrix
	F = [[0] * n for i in range(n)]
	path = bfs(C, F, s, t)
	while path != None:
		flow = min(C[u][v] - F[u][v] for u, v in path)
		for u, v in path:
			F[u][v] += flow
			F[v][u] -= flow
		path = bfs(C, F, s, t)
	return F,sum(F[s][i] for i in range(n))

def display_flows(adjmat,relevant_nodes):
	'''
		Display the flow values between relevant nodes in a given adjacency matrix.

		Inputs:
			adjmat (list of lists): The adjacency matrix representing the flow network.
			relevant_nodes (list): A list of node labels corresponding to the nodes of interest.

		Outputs:
			None: The function prints the flow values between relevant nodes.
	'''
	for source,row in enumerate(adjmat):
		for sink,value in enumerate(row):
			if value > 0:
				print(relevant_nodes[source] + " [" + str(value) + "] " + relevant_nodes[sink])

def get_max_flow(flows,chemistry,regions,max_dep):
	'''
	Calculates the maximum flow between countries related to a specific chemistry process.

	Three start points - mining, refining, cathode
	Returns an adjacency matrix that describes the flows between countries.

	Inputs:
		flows (DataFrame): DataFrame containing information about flows between countries.
		chemistry (str): The specific chemistry process of interest (e.g., "LFP").
		regions (list): List of country or region names involved in the flows.
		max_dep (list): List of maximum production limits for each stage of the process.

	Outputs:
		tuple: Returns a tuple containing two elements:
			- A 2D list (matrix) representing the adjacency matrix describing flows between relevant nodes.
			- An integer representing the maximum flow value.
	'''
	
	relevant_nodes = ["supersource"]

	upwards = dfs(flows,chemistry,True)

	# Do DFS from all relevant mining, then refining, then cathode manuf., if possible
	for ext in ["_mine", "_ref_poss", "_ref", "_cath_poss",""]:
		for region in regions:
			reg = region + ext
			downwards = dfs(flows,reg,False)

			for node in downwards:
				if node in upwards:
					if node not in relevant_nodes:
						relevant_nodes.append(node)

	# Make an adjacency matrix the size of len(relevant_nodes)^2
	adjmat = [[0]*len(relevant_nodes) for a in range(len(relevant_nodes))]

	# Connect supersource [0] to regions
	for region in regions:
		for en,ext in enumerate(["_mine", "_ref_poss", "_ref", "_cath_poss", ""]):
			try:
				rn = relevant_nodes.index(region + ext)
			except ValueError:
				continue # Go to next, this doesn't exist in the flows
			# Assign the supersource the minimum value between the total amount (which may or may not include missing data),
			# and the known maximum amount of production in the country up to that point
			# print(chemistry, ext, sum(flows[flows["Source"] == (region + ext)]["Value"]) <= max_dep[en])
			adjmat[0][rn] = min(sum(flows[flows["Source"] == (region + ext)]["Value"]),max_dep[en])

	# Iterate through the rest of the relevant nodes and try to find all of the flows
	for ind1,source in enumerate(relevant_nodes):
		for ind2,target in enumerate(relevant_nodes):
			flow = flows.loc[(flows["Source"] == source) & (flows["Target"] == target)]
			if not flow.empty:
				adjmat[ind1][ind2] = float(flow["Value"])

	if PRINT_debug: print(relevant_nodes,adjmat)

	if len(relevant_nodes) > 1:
		f,mf = max_flow(adjmat,0,relevant_nodes.index(chemistry))
	else:
		if PRINT_out: print(str(regions) + " are not related to " + chemistry + " at all - returning 0")
		f,mf = adjmat,0
	
	if PRINT_out: 
		if ACRO[0] in regions: 
			print("\nMax Flow Possible Set w/ uncertain")
		else: 
			print("\nMax Flow Possible Set")
		display_flows(f,relevant_nodes)

	return f,mf

def get_min_flow(flows,chemistry,regions,tot_amt):
	'''
	Aim to maximize the amount of flow not involving the regions at all 
	--> remove the regions completely from the graph.

	Inputs:
		flows (DataFrame): DataFrame containing information about flows between countries.
		chemistry (str): The specific chemistry process of interest (e.g., "LFP").
		regions (list): List of country or region names involved in the flows.
		tot_amt (int): Total amount of flow to be considered.

	Outputs:
		tuple: Returns a tuple containing two elements:
			- A 2D list (matrix) representing the adjacency matrix describing flows between relevant nodes.
			- An integer representing the minimum flow dependence on the specified regions.
	'''
	relevant_nodes = ["supersource"]

	# Get all nodes that the chemistry is connected to 
	upwards = dfs(flows,chemistry,True)

	# Remove all nodes that are related to regions 
	for node in reversed(upwards): # reverse  
		ns = node.split("_")[0]
		if ns not in regions: # and ns not in ACRO and node not in ACRO - do not include missing data FOR NOW (we assume it's not part)
			relevant_nodes.append(node)

	# Make an adjacency matrix the size of len(relevant_nodes)^2
	adjmat = [[0]*len(relevant_nodes) for a in range(len(relevant_nodes))]

	# Connect supersource [0] to all mining not in regions + missing data (!!) 
	for ind,flow in flows.iterrows():
		source = flow["Source"].split("_")
		# Connect to mining
		if len(source) > 1 and source[1] == "mine" and flow["Source"] in relevant_nodes:
			adjmat[0][relevant_nodes.index(flow["Source"])] = tot_amt
		elif flow["Source"] in ACRO:
			adjmat[0][relevant_nodes.index(flow["Source"])] = tot_amt

	if PRINT_debug:
		print(relevant_nodes)
		for ind,row in enumerate(adjmat):
			print(relevant_nodes[ind])
			for ind2,val in enumerate(row):
				if val >0:
					print(relevant_nodes[ind2],val)


	# Iterate through the rest of the relevant nodes and try to find all of the flows
	for ind1,source in enumerate(relevant_nodes):
		for ind2,target in enumerate(relevant_nodes):
			flow = flows.loc[(flows["Source"] == source) & (flows["Target"] == target)]
			if not flow.empty:
				adjmat[ind1][ind2] = float(flow["Value"])

	if PRINT_debug: print(adjmat)

	if len(relevant_nodes) > 1:
		f,mf = max_flow(adjmat,0,relevant_nodes.index(chemistry))
	else:
		if PRINT_out: print(str(regions) + " are not related to " + chemistry + " at all - returning 0")
		f,mf = adjmat,tot_amt

	if PRINT_out: 
		print("\nMin Flow Possible Set")
		display_flows(f,relevant_nodes)

	# The max flow calculated is the maximum not dependent on the regions. 
	# Thus, we should subtract it from the total amount to get the minimum dependence. 
	return f,tot_amt-mf

def dfs_prop(flows,regions,target,ratio):
	'''
		Perform a depth-first search (DFS) to calculate the proportion of flow upstream to a target.

		Inputs:
			flows (DataFrame): DataFrame containing information about flows between countries.
			regions (list): List of country or region names involved in the flows.
			target (str): The target country or region for which the proportion of upstream flow is calculated.
			ratio (float): The proportion of flow to be considered (must be between 0 and 1).

		Outputs:
			float: Returns the total proportion of flow upstream to the specified target.
	'''
	amt = 0

	if ratio > 1:
		ratio = 1

	# Get all countries upstream, if any
	up_row_full = flows.loc[(flows["Target"] == target)]
	mask = up_row_full["Source"].isin(ACRO) # Need to get rows that's don't include missing
	upstream_rows = up_row_full[~mask]

	# If exists,
	if not upstream_rows.empty:

		step_tot = sum(list(upstream_rows["Value"])) 

		# Check to see if any of those rows are one of the regions
		for ind,row in upstream_rows.iterrows():
			s = row["Source"].split("_")[0]
			# print(row["Source"],amt)
			if s not in regions:
				# Iterate to determine amount dependent upstream 
				val = dfs_prop(flows,regions,row["Source"],float(row["Value"])/step_tot*ratio)
				if val > 0:
					# Record to ledger
					if PRINT_out: print(str(row["Source"]) + " [" + str(val) + "] " + target)
					amt += val
			else:
				# In regions, add to amount
				val = float(row["Value"])/step_tot*ratio
				if PRINT_out: print(str(row["Source"]) + " [" + str(val) + "] " + target)
				if PRINT_debug: print(ratio)
				amt += val

			if PRINT_debug and val > 0: print(str(row["Source"]),val,ratio,step_tot)
	return amt

def calculate(flows,chemistry,material,regions,limit=None):
	'''
	Calculate the dependence/vulnerability of a specific chemistry-material pair on upstream sources.

	Inputs:
		flows (DataFrame): DataFrame containing information about flows between countries.
		chemistry (str): The specific chemistry process of interest (e.g., "LFP").
		material (str): The material associated with the chemistry under analysis. (e.g. "Lithium")
		regions (list): List of country or region names involved in the flows.
		limit (str): Optional. Specifies the limit condition for dependence calculation.
					 Possible values: "max_no_miss", "max_miss", "min", or None (default, proportional dependence).

	Outputs:
		float: Returns the calculated vulnerability value based on the specified limit condition.
	'''

	# In-line percent function
	pc = lambda f: f"{f*100:.2f}%"

	# Read in the flows data, which is in the form [Source], [Target], [Value]
	tot_amt = sum(flows.loc[(flows["Target"] == chemistry)]["Value"])
	# Calculate maximum amount of dependence, based on the amount of material touching each country at each step 
	max_mine_dep = 0
	max_ref_dep = 0
	max_cath_dep = 0
	for region in regions:
		reg_mine = sum(flows.loc[(flows["Source"] == region + "_mine")]["Value"]) # Mining
		reg_ref = sum(flows.loc[(flows["Source"] == region + "_ref")]["Value"]) # Refining
		reg_cath = sum(flows.loc[(flows["Source"] == region + "_cath_poss") & (flows["Target"] == chemistry)]["Value"]) # Cathode Production 
		max_mine_dep += reg_mine
		max_ref_dep += (reg_mine + reg_ref)
		max_cath_dep += (reg_mine + reg_ref + reg_cath)
	max_dep = [max_mine_dep,max_ref_dep,max_ref_dep,max_cath_dep,max_cath_dep]
	
	# Convert flows to relevant flows matrix 
	# Here is where you would swap between min and max flow (w/ and w/o uncertainty) depending on selection
	if limit == "max_no_miss":
		mf_mat,mf_val = get_max_flow(flows,chemistry,regions,max_dep)
		if PRINT_out: print("For " + chemistry + "-" + material + " in " + str(regions) + ", " + str(mf_val) + " of " + str(tot_amt) + " or " + str(pc(mf_val/tot_amt)) + " is maximally dependent (no missing data)")
	elif limit == "max_miss":
		r = regions + ACRO
		mf_mat,mf_val = get_max_flow(flows,chemistry,r,max_dep)
		if PRINT_out: print("For " + chemistry + "-" + material + " in " + str(regions) + ", " + str(mf_val) + " of " + str(tot_amt) + " or " + str(pc(mf_val/tot_amt)) + " is maximally dependent (includes missing data)")
	elif limit == "min":
		mf_mat,mf_val = get_min_flow(flows,chemistry,regions,tot_amt)
		if PRINT_out: print("For " + chemistry + "-" + material + " in " + str(regions) + ", " + str(mf_val) + " of " + str(tot_amt) + " or " + str(pc(mf_val/tot_amt)) + " is minimally dependent")
	else: # Default is Proportional
		# For this script - do DFS, construct the tree, look at dependency at each branch. 
		visited = []
		stack = [chemistry]
		if PRINT_out: print("\nProp flow set")
		amt = dfs_prop(flows,regions,chemistry,1)
		if PRINT_out: print("For " + chemistry + "-" + material + " in " + str(regions) + ", " + str(pc(amt)) + " is proportionally dependent")
		return amt
	return mf_val/tot_amt

def plot(cmps,regions_set,plotdep,props,mins,errs,max_knowns):
	   '''
	Plot a bar chart visualizing the percentage dependence or independence of regions on different chemistry components.

	Inputs:
		cmps (int): The number of cathode-mineral pairs being analyzed.
		regions_set (list): List of country or region names involved in the analysis.
		plotdep (bool): If True, plot the percentage dependence/vulnerable; if False, plot the percentage not dependent/not vulnerable.
		props (list): List of lists containing the percentage dependence/vulnerability for each cathode-mineral pair.
		mins (list): List of lists containing the minimum values for error bars for each cathode-mineral pair.
		errs (list): List of lists containing the error values for each cathode-mineral pair.
		max_knowns (list): List of lists containing the maximum known values for each cathode-mineral pair.

	Outputs:
		None: Displays the bar chart plot.
	'''
	fig, ax = plt.subplots(figsize=(6,2.4)) # Set fig size here
	ns = len(regions_set)
	x = np.arange(ns)  # the label locations

	# Edit chemistry colors and x-labels
	chem_colors = ["#76a5af","#a2c4c9","#1155cc","#6aa84f","#666666"] 
	xlabs = []
	for region in regions_set:
		if len(region) == 1:
			xlabs.append(commonname(region)[0])
		else:
			xlabs.append(str(commonname(region)))

	print(xlabs)

	# width = 0.40 # the width of the group of bars 
	width = 0.60  # the width of the group of bars
	
	for enum in range(cmps):
		xpos = x-width/2+width/cmps/2+width/cmps*enum
		print(xpos,props[enum],width/cmps,chem_colors[enum])
		bar = ax.bar(xpos, props[enum], width/cmps, color=chem_colors[enum])
		ax.bar_label(bar,padding=3, labels=["" for a in range(len(regions_set))])
		ax.errorbar(xpos,mins[enum],yerr=errs[enum],fmt='none',ecolor='#FFA500',capsize=2)
		ax.scatter(xpos,max_knowns[enum],marker="x",s=25,color='#FFA500')

	ax.yaxis.set_major_formatter(mtick.PercentFormatter(xmax=1.0))

	if plotdep:
		ax.set_ylabel('Percentage Dependent')
	else:
		ax.set_ylabel('Percentage Not Dependent')
	ax.set_xticks(x, xlabs)

	plt.show()


if __name__ == '__main__':

	# Config flags for controllling output display and debugging
	PRINT_res = False # Print results
	PRINT_out = False # Print detailed output
	PRINT_debug = False # Print debugging information

	PLOT = True # Enable plotting
	plotdep = True # True - plot amount dependent/vulnerable. False - plot amount non-dependent. 


	# Define sets of regions for analysis
	# regions_set = [["China"],["Russian Federation"],["Congo, Democratic Republic of the"],["South Africa"],["Chile","Argentina"],["Korea, Republic of","Japan"],["India"]]
	# regions_set = [["China"],["Russian Federation"],["Congo, Democratic Republic of the"],["South Africa"],["Australia"],["Korea, Republic of","Japan"]]
	# regions_set = [["China"],["Russian Federation"],["Congo, Democratic Republic of the"],["South Africa"],["Australia"],["United States of America"]]
	# regions_set = [["China"],["Russian Federation"],["Congo, Democratic Republic of the"],["South Africa"],["Australia"],["Korea, Republic of","Japan"],["United States of America"]]
	regions_set = [["China"],["Russian Federation"],["Congo, Democratic Republic of the"],["South Africa"]]
	# regions_set = [["Australia"],["Korea, Republic of"],["Japan"],["United States of America"],["United Kingdom","France",
	# 			"Spain","Portugal","Germany","Netherlands","Austria","Sweden","Finland","Norway","Belgium","Poland","Austria",
	# 			"Switzerland","Italy","Hungary","Czech Republic","Slovakia","Ireland","Greece","Romania","Bulgaria","Estonia",
	# 			"Latvia","Lithuania","Cyprus"]]
	# regions_set = [["Congo, Democratic Republic of the"]]
	# regions_set = [["United States of America","Australia","Canada","Chile","Colombia","Costa Rica","Guatemala","Mexico","Morocco","South Korea"],
				# ["China","Russian Federation"],["China","Congo, Democratic Republic of the","Philippines","Indonesia"],
				# ["Chile","Argentina","Bolivia","Brazil","Peru"]]
	# "Trade bloc avoidance"
	# regions_set = [[]]
	# regions_set = [["China"]]
	cmps = 5 # cathode-mineral pairs - currently 5 - LFP-Li, NCM-Li, NCM-Ni, NCM-Co, NCM-Mn

	# Initialize lists for storing data for each cathode-mineral pair
	props = [[] for a in range(cmps)]
	mins = [[] for a in range(cmps)]
	errs = [ [[],[]] for a in range(cmps) ]
	maxs = [[] for a in range(cmps)]

	# Loop through each set of regions and cathode-mineral pair
	for regions in regions_set:
		for enum,pair in enumerate([["LFP","Lithium"], ["NCM","Lithium"], ["NCM","Cobalt"], ["NCM","Nickel"], ["NCM","Manganese"]]):
		# for enum,pair in enumerate([["LFP","Lithium"]]):
		# for enum,pair in enumerate([["NCM","Lithium"]]):
		# for enum,pair in enumerate([["NCM","Nickel"]]):
		# for enum,pair in enumerate([["NCM","Manganese"]]):
		# for enum,pair in enumerate([["NCM","Cobalt"]]):
			chem,mineral = pair
			flows = pd.read_csv(mineral+"_Sankey_data.csv")
			if PRINT_out: print(flows.to_string())

			# Calculate dependence metrics for different limit conditions
			max_known = calculate(flows,chem,mineral,regions,"max_no_miss")
			maximum = calculate(flows,chem,mineral,regions,"max_miss")
			minimum = calculate(flows,chem,mineral,regions,"min")
			prop = calculate(flows,chem,mineral,regions,"prop")

			# Adjust values and errors for plotting depending on plotdep flag
			if plotdep:
				errs[enum][0].append(0)
				errs[enum][1].append(max_known - minimum)
			else:
				prop = 1 - prop
				minimum = 1 - minimum
				maximum = 1 - maximum
				max_known = 1 - max_known
				errs[enum][0].append(max_known - minimum)
				errs[enum][1].append(0)

			if PRINT_res: print(regions,prop,minimum,max_known,maximum)

			# Store calculated values in lists
			props[enum].append(prop)
			mins[enum].append(minimum)
			maxs[enum].append(maximum)

	if PLOT:
		# if not working - check - are we analyzing all minerals?
		plot(cmps,regions_set,plotdep,props,mins,errs,maxs)

	









